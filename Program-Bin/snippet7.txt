// Cache-friendly point structure for vectorization
struct alignas(32) HighPrecisionPoint {
    array<Float64, 4> coordinates; // 32-byte aligned for AVX2
    Int64 dimension;
    
    HighPrecisionPoint(Int64 dim = 2) : dimension(dim) {
        coordinates.fill(0.0);
    }
    
    HighPrecisionPoint(const vector<Float64>& coords) : dimension(coords.size()) {
        for (Int64 i = 0; i < min(static_cast<Int64>(coords.size()), 4LL); i++) {
            coordinates[i] = coords[i];
        }
    }
    
    Float64& operator[](Int64 index) { return coordinates[index]; }
    const Float64& operator[](Int64 index) const { return coordinates[index]; }
    
    // SIMD-accelerated distance calculation
    Float64 distance_simd(const HighPrecisionPoint& other) const {
        __m256d diff1 = _mm256_sub_pd(_mm256_load_pd(coordinates.data()), 
                                     _mm256_load_pd(other.coordinates.data()));
        __m256d square = _mm256_mul_pd(diff1, diff1);
        
        // Horizontal sum
        Float64 sum_array[4];
        _mm256_store_pd(sum_array, square);
        return sqrt(sum_array[0] + sum_array[1] + sum_array[2] + sum_array[3]);
    }
};

class ExtremePerformanceKMeans {
private:
    vector<HighPrecisionPoint> data;
    vector<HighPrecisionPoint> centroids;
    vector<Int64> labels;
    Int64 k;
    Int64 max_iterations;
    PrecisionTimer timer;
    
public:
    ExtremePerformanceKMeans(const vector<vector<Float64>>& input_data, Int64 clusters, 
                           Int64 max_iters = 100)
        : k(clusters), max_iterations(max_iters) {
        // Convert to aligned points
        data.reserve(input_data.size());
        for (const auto& point : input_data) {
            data.emplace_back(point);
        }
    }
    
    void initializeCentroidsSmart() {
        centroids.clear();
        random_device rd;
        mt19937 gen(rd());
        
        // K-means++ initialization for better convergence
        uniform_int_distribution<Int64> first_dist(0, data.size() - 1);
        centroids.push_back(data[first_dist(gen)]);
        
        vector<Float64> distances(data.size(), numeric_limits<Float64>::max());
        
        for (Int64 cluster = 1; cluster < k; cluster++) {
            // Update distances to nearest centroid
            #pragma omp parallel for
            for (Int64 i = 0; i < static_cast<Int64>(data.size()); i++) {
                Float64 min_dist = numeric_limits<Float64>::max();
                for (Int64 j = 0; j < cluster; j++) {
                    Float64 dist = data[i].distance_simd(centroids[j]);
                    if (dist < min_dist) {
                        min_dist = dist;
                    }
                }
                distances[i] = min_dist;
            }
            
            // Convert to probabilities
            Float64 total_distance = accumulate(distances.begin(), distances.end(), 0.0);
            vector<Float64> probabilities(data.size());
            transform(execution::par_unseq, distances.begin(), distances.end(),
                     probabilities.begin(), [total_distance](Float64 d) { 
                         return d / total_distance; });
            
            // Roulette wheel selection
            discrete_distribution<Int64> dist(probabilities.begin(), probabilities.end());
            centroids.push_back(data[dist(gen)]);
        }
    }
    
    void clusterUltraFast() {
        timer.start();
        initializeCentroidsSmart();
        labels.resize(data.size());
        
        vector<Int64> cluster_sizes(k, 0);
        vector<HighPrecisionPoint> new_centroids(k, HighPrecisionPoint(data[0].dimension));
        
        for (Int64 iter = 0; iter < max_iterations; iter++) {
            // Parallel assignment phase
            #pragma omp parallel for
            for (Int64 i = 0; i < static_cast<Int64>(data.size()); i++) {
                Float64 min_distance = numeric_limits<Float64>::max();
                Int64 best_cluster = 0;
                
                for (Int64 j = 0; j < k; j++) {
                    Float64 distance = data[i].distance_simd(centroids[j]);
                    if (distance < min_distance) {
                        min_distance = distance;
                        best_cluster = j;
                    }
                }
                labels[i] = best_cluster;
            }
            
            // Reset centroids
            fill(cluster_sizes.begin(), cluster_sizes.end(), 0);
            for (auto& centroid : new_centroids) {
                fill(centroid.coordinates.begin(), centroid.coordinates.end(), 0.0);
            }
            
            // Accumulate points for new centroids
            for (Int64 i = 0; i < static_cast<Int64>(data.size()); i++) {
                Int64 cluster = labels[i];
                cluster_sizes[cluster]++;
                for (Int64 dim = 0; dim < data[i].dimension; dim++) {
                    new_centroids[cluster][dim] += data[i][dim];
                }
            }
            
            // Calculate new centroids and check convergence
            bool converged = true;
            for (Int64 j = 0; j < k; j++) {
                if (cluster_sizes[j] > 0) {
                    HighPrecisionPoint new_centroid(data[0].dimension);
                    for (Int64 dim = 0; dim < new_centroid.dimension; dim++) {
                        new_centroid[dim] = new_centroids[j][dim] / cluster_sizes[j];
                    }
                    
                    if (new_centroid.distance_simd(centroids[j]) > 1e-8) {
                        converged = false;
                    }
                    centroids[j] = new_centroid;
                }
            }
            
            if (converged) break;
        }
        
        double elapsed = timer.elapsed();
        cout << "=== EXTREME PERFORMANCE K-MEANS ===" << endl;
        cout << "Clusters: " << k << endl;
        cout << "Data points: " << data.size() << endl;
        cout << "Convergence time: " << elapsed * 1000 << " ms" << endl;
        cout << "Points per second: " << data.size() / elapsed << endl;
    }
    
    void printClusterStats() {
        vector<Int64> cluster_sizes(k, 0);
        for (Int64 label : labels) {
            cluster_sizes[label]++;
        }
        
        cout << "\nCluster Distribution:" << endl;
        for (Int64 i = 0; i < k; i++) {
            cout << "Cluster " << i << ": " << cluster_sizes[i] 
                 << " points (" << (100.0 * cluster_sizes[i] / data.size()) << "%)" << endl;
        }
        
        // Calculate within-cluster sum of squares
        Float64 total_wcss = 0.0;
        #pragma omp parallel for reduction(+:total_wcss)
        for (Int64 i = 0; i < static_cast<Int64>(data.size()); i++) {
            total_wcss += data[i].distance_simd(centroids[labels[i]]);
        }
        cout << "Total WCSS: " << total_wcss << endl;
    }
    
    vector<Int64> getLabels() const { return labels; }
    vector<HighPrecisionPoint> getCentroids() const { return centroids; }
};

class ExtremePerformancePCA {
private:
    vector<vector<Float64>> data;
    vector<vector<Float64>> components;
    vector<Float64> explained_variance;
    vector<Float64> eigenvalues;
    PrecisionTimer timer;
    
public:
    ExtremePerformancePCA(const vector<vector<Float64>>& input_data) 
        : data(input_data) {}
    
    void performUltraPCA(Int64 n_components = 2) {
        timer.start();
        
        // Center the data using SIMD operations
        auto centered_data = centerDataUltra();
        
        // Compute covariance matrix efficiently
        auto cov_matrix = computeCovarianceMatrixUltra(centered_data);
        
        // Use power iteration with deflation for multiple components
        components.clear();
        eigenvalues.clear();
        
        for (Int64 comp = 0; comp < n_components; comp++) {
            auto eigenpair = powerIterationWithDeflation(cov_matrix, components);
            components.push_back(eigenpair.first);
            eigenvalues.push_back(eigenpair.second);
        }
        
        // Calculate explained variance
        Float64 total_variance = 0.0;
        for (const auto& row : cov_matrix) {
            for (Float64 val : row) {
                total_variance += abs(val);
            }
        }
        
        explained_variance.clear();
        for (Float64 eval : eigenvalues) {
            explained_variance.push_back(eval / total_variance);
        }
        
        double elapsed = timer.elapsed();
        cout << "=== EXTREME PERFORMANCE PCA ===" << endl;
        cout << "Components: " << n_components << endl;
        cout << "Data dimensions: " << data[0].size() << " -> " << n_components << endl;
        cout << "Computation time: " << elapsed * 1000 << " ms" << endl;
    }
    
private:
    vector<vector<Float64>> centerDataUltra() {
        vector<vector<Float64>> centered = data;
        Int64 n_features = data[0].size();
        Int64 n_samples = data.size();
        
        // Calculate column means in parallel
        vector<Float64> column_means(n_features, 0.0);
        #pragma omp parallel for
        for (Int64 j = 0; j < n_features; j++) {
            Float64 sum = 0.0;
            for (Int64 i = 0; i < n_samples; i++) {
                sum += data[i][j];
            }
            column_means[j] = sum / n_samples;
        }
        
        // Center data in parallel
        #pragma omp parallel for collapse(2)
        for (Int64 i = 0; i < n_samples; i++) {
            for (Int64 j = 0; j < n_features; j++) {
                centered[i][j] -= column_means[j];
            }
        }
        
        return centered;
    }
    
    vector<vector<Float64>> computeCovarianceMatrixUltra(const vector<vector<Float64>>& centered_data) {
        Int64 n_samples = centered_data.size();
        Int64 n_features = centered_data[0].size();
        
        vector<vector<Float64>> cov_matrix(n_features, vector<Float64>(n_features, 0.0));
        
        // Parallel covariance computation
        #pragma omp parallel for collapse(2)
        for (Int64 i = 0; i < n_features; i++) {
            for (Int64 j = i; j < n_features; j++) {
                Float64 sum = 0.0;
                for (Int64 k = 0; k < n_samples; k++) {
                    sum += centered_data[k][i] * centered_data[k][j];
                }
                cov_matrix[i][j] = sum / (n_samples - 1);
                cov_matrix[j][i] = cov_matrix[i][j]; // Symmetric
            }
        }
        
        return cov_matrix;
    }
    
    pair<vector<Float64>, Float64> powerIterationWithDeflation(
        const vector<vector<Float64>>& matrix, 
        const vector<vector<Float64>>& existing_components) {
        
        Int64 n = matrix.size();
        vector<Float64> eigenvector(n, 1.0 / sqrt(n));
        
        for (Int64 iter = 0; iter < 200; iter++) {
            vector<Float64> new_vector(n, 0.0);
            
            // Matrix-vector multiplication
            #pragma omp parallel for
            for (Int64 i = 0; i < n; i++) {
                for (Int64 j = 0; j < n; j++) {
                    new_vector[i] += matrix[i][j] * eigenvector[j];
                }
            }
            
            // Orthogonalize against existing components
            for (const auto& comp : existing_components) {
                Float64 dot_product = 0.0;
                for (Int64 i = 0; i < n; i++) {
                    dot_product += new_vector[i] * comp[i];
                }
                for (Int64 i = 0; i < n; i++) {
                    new_vector[i] -= dot_product * comp[i];
                }
            }
            
            // Normalize
            Float64 norm = 0.0;
            for (Float64 val : new_vector) norm += val * val;
            norm = sqrt(norm);
            
            Float64 max_change = 0.0;
            for (Int64 i = 0; i < n; i++) {
                Float64 change = abs(new_vector[i] / norm - eigenvector[i]);
                if (change > max_change) max_change = change;
                eigenvector[i] = new_vector[i] / norm;
            }
            
            if (max_change < 1e-12) break;
        }
        
        // Compute eigenvalue
        Float64 eigenvalue = 0.0;
        vector<Float64> Ax(n, 0.0);
        for (Int64 i = 0; i < n; i++) {
            for (Int64 j = 0; j < n; j++) {
                Ax[i] += matrix[i][j] * eigenvector[j];
            }
            eigenvalue += Ax[i] * eigenvector[i];
        }
        
        return {eigenvector, eigenvalue};
    }
    
public:
    void printPrecisionResults() {
        cout << "\nPrincipal Components Analysis:" << endl;
        cout << "Explained variance ratios:" << endl;
        for (size_t i = 0; i < explained_variance.size(); i++) {
            cout << "PC" << i+1 << ": " << explained_variance[i] * 100 << "%" << endl;
        }
        
        cout << "\nCumulative explained variance:" << endl;
        Float64 cumulative = 0.0;
        for (size_t i = 0; i < explained_variance.size(); i++) {
            cumulative += explained_variance[i];
            cout << "First " << i+1 << " PCs: " << cumulative * 100 << "%" << endl;
        }
        
        cout << "\nTop component loadings:" << endl;
        for (size_t i = 0; i < min(components.size(), size_t(2)); i++) {
            cout << "PC" << i+1 << ": [";
            for (size_t j = 0; j < min(components[i].size(), size_t(5)); j++) {
                cout << components[i][j] << (j < 4 ? ", " : "");
            }
            if (components[i].size() > 5) cout << "...";
            cout << "]" << endl;
        }
    }
    
    vector<vector<Float64>> transformData(const vector<vector<Float64>>& new_data, 
                                        Int64 n_components = -1) {
        if (n_components == -1) n_components = components.size();
        
        vector<vector<Float64>> transformed;
        transformed.reserve(new_data.size());
        
        for (const auto& point : new_data) {
            vector<Float64> projected(n_components, 0.0);
            for (Int64 comp = 0; comp < n_components; comp++) {
                for (size_t i = 0; i < point.size(); i++) {
                    projected[comp] += point[i] * components[comp][i];
                }
            }
            transformed.push_back(projected);
        }
        
        return transformed;
    }
};