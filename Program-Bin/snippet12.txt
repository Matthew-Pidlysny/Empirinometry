#include <iostream>
#include <vector>
#include <cmath>
#include <iomanip>
#include <limits>
#include <string>
#include <memory>
#include <sstream>

using namespace std;

// Tree node representing a step in the mathematical understanding
struct MathNode {
    string concept;           // The mathematical concept at this level
    string formula;           // Key formula or relationship
    string insight;           // What we learn from this
    vector<shared_ptr<MathNode>> children;
    int depth;
    
    MathNode(string c, string f, string i, int d = 0) 
        : concept(c), formula(f), insight(i), depth(d) {}
    
    void addChild(shared_ptr<MathNode> child) {
        child->depth = this->depth + 1;
        children.push_back(child);
    }
};

// Visual tree renderer
class MathTree {
private:
    shared_ptr<MathNode> root;
    
    void printNode(const shared_ptr<MathNode>& node, string prefix = "", bool isLast = true) {
        if (!node) return;
        
        // Print the connector
        cout << prefix;
        if (node->depth > 0) {
            cout << (isLast ? "└── " : "├── ");
        }
        
        // Print the concept with styling
        cout << "\033[1;36m" << node->concept << "\033[0m" << endl;
        
        // Print formula if present
        if (!node->formula.empty()) {
            cout << prefix << (isLast ? "    " : "│   ") 
                 << "\033[1;33m⚡ " << node->formula << "\033[0m" << endl;
        }
        
        // Print insight if present
        if (!node->insight.empty()) {
            cout << prefix << (isLast ? "    " : "│   ") 
                 << "\033[0;32m→ " << node->insight << "\033[0m" << endl;
        }
        
        if (!node->children.empty()) {
            cout << prefix << (isLast ? "    " : "│   ") << endl;
        }
        
        // Print children
        string newPrefix = prefix + (isLast ? "    " : "│   ");
        for (size_t i = 0; i < node->children.size(); i++) {
            bool lastChild = (i == node->children.size() - 1);
            printNode(node->children[i], newPrefix, lastChild);
        }
    }
    
public:
    MathTree() {
        buildTree();
    }
    
    void buildTree() {
        // ROOT: The fundamental question
        root = make_shared<MathNode>(
            "How do we find rational numbers that best represent any real number?",
            "",
            "We need a systematic way to approximate irrationals with fractions"
        );
        
        // LEVEL 1: The Euclidean Algorithm Foundation
        auto euclidean = make_shared<MathNode>(
            "Euclidean Algorithm",
            "gcd(a,b) via repeated division: a = b·q + r",
            "Division creates a sequence of remainders converging to the essence"
        );
        root->addChild(euclidean);
        
        // LEVEL 2a: From Euclidean to Continued Fractions
        auto cfExtraction = make_shared<MathNode>(
            "Continued Fraction Extraction",
            "x = a₀ + 1/(a₁ + 1/(a₂ + 1/(a₃ + ...)))",
            "Any real number unfolds as nested reciprocals"
        );
        euclidean->addChild(cfExtraction);
        
        // LEVEL 3a: The Coefficients
        auto coefficients = make_shared<MathNode>(
            "CF Coefficients [a₀; a₁, a₂, ...]",
            "aₙ = ⌊remainder⌋, then invert fractional part",
            "Each coefficient captures one layer of rational approximation"
        );
        cfExtraction->addChild(coefficients);
        
        // LEVEL 4a: Convergents emerge
        auto convergents = make_shared<MathNode>(
            "Convergents: The Rational Approximations",
            "pₙ/qₙ where pₙ = aₙ·pₙ₋₁ + pₙ₋₂, qₙ = aₙ·qₙ₋₁ + qₙ₋₂",
            "Each convergent is the BEST approximation for its denominator size"
        );
        coefficients->addChild(convergents);
        
        // LEVEL 5a: Optimality Proof
        auto optimality = make_shared<MathNode>(
            "Legendre's Theorem (Optimality)",
            "|x - pₙ/qₙ| < 1/(qₙ·qₙ₊₁)",
            "No fraction with smaller denominator can be closer!"
        );
        convergents->addChild(optimality);
        
        // LEVEL 2b: Pattern Recognition Branch
        auto patterns = make_shared<MathNode>(
            "Pattern Recognition in CF Coefficients",
            "",
            "The sequence [a₀; a₁, a₂, ...] reveals the number's nature"
        );
        root->addChild(patterns);
        
        // LEVEL 3b: Golden Ratio
        auto golden = make_shared<MathNode>(
            "All 1s Pattern → Golden Ratio φ",
            "φ = [1; 1, 1, 1, ...] where φ = 1 + 1/φ",
            "The simplest CF = the most irrational number (Hurwitz)"
        );
        patterns->addChild(golden);
        
        // LEVEL 4b: Fibonacci Connection
        auto fibonacci = make_shared<MathNode>(
            "Convergents are Fibonacci Ratios",
            "Fₙ₊₁/Fₙ → φ as n → ∞",
            "The golden ratio emerges from the simplest recurrence"
        );
        golden->addChild(fibonacci);
        
        // LEVEL 3c: Euler's Number
        auto euler = make_shared<MathNode>(
            "[1, 2n, 1] Pattern → Euler's Number e",
            "e = [2; 1,2,1, 1,4,1, 1,6,1, ...]",
            "Arithmetic pattern in CF reveals exponential constant"
        );
        patterns->addChild(euler);
        
        // LEVEL 3d: Periodic Patterns
        auto periodic = make_shared<MathNode>(
            "Periodic CFs → Quadratic Irrationals",
            "√n has eventually periodic CF",
            "Solutions to x² - Dx + E = 0 have repeating patterns"
        );
        patterns->addChild(periodic);
        
        // LEVEL 4c: Square Root Example
        auto sqrt2 = make_shared<MathNode>(
            "√2 = [1; 2, 2, 2, ...]",
            "Period of length 1, coefficient is 2",
            "Simplest quadratic irrational after φ"
        );
        periodic->addChild(sqrt2);
        
        // LEVEL 2c: Diophantine Approximation
        auto diophantine = make_shared<MathNode>(
            "Diophantine Approximation Theory",
            "",
            "How well can rationals approximate irrationals?"
        );
        root->addChild(diophantine);
        
        // LEVEL 3e: Hurwitz Theorem
        auto hurwitz = make_shared<MathNode>(
            "Hurwitz's Theorem",
            "|x - p/q| < 1/(√5·q²) infinitely often",
            "√5 appears because φ = (1+√5)/2 is hardest to approximate"
        );
        diophantine->addChild(hurwitz);
        
        // LEVEL 4d: The Crown
        auto crown = make_shared<MathNode>(
            "φ is the 'Most Irrational' Number",
            "Slowest converging CF = hardest to approximate",
            "The golden ratio sits at the pinnacle of irrationality"
        );
        hurwitz->addChild(crown);
        
        // LEVEL 2d: Practical Applications
        auto applications = make_shared<MathNode>(
            "Practical Applications",
            "",
            "Where do we use these insights?"
        );
        root->addChild(applications);
        
        auto calendar = make_shared<MathNode>(
            "Calendar Systems",
            "Year ≈ 365.2422 days → CF finds leap year patterns",
            "Convergents give optimal calendar approximations"
        );
        applications->addChild(calendar);
        
        auto music = make_shared<MathNode>(
            "Musical Harmony",
            "Frequency ratios as continued fractions",
            "Small denominators = consonant intervals"
        );
        applications->addChild(music);
        
        auto computing = make_shared<MathNode>(
            "Computational Precision",
            "Best rational fits within floating point limits",
            "Minimize error for fixed-point arithmetic"
        );
        applications->addChild(computing);
    }
    
    void display() {
        cout << "\n";
        cout << "╔════════════════════════════════════════════════════════════════════════════╗" << endl;
        cout << "║                    TREE OF MATHEMATICAL UNDERSTANDING                      ║" << endl;
        cout << "║                  Continued Fractions & Rational Approximation              ║" << endl;
        cout << "╚════════════════════════════════════════════════════════════════════════════╝" << endl;
        cout << "\n";
        cout << "Legend: \033[1;36mConcept\033[0m  \033[1;33m⚡Formula\033[0m  \033[0;32m→Insight\033[0m\n" << endl;
        cout << "\n";
        
        printNode(root);
        
        cout << "\n";
        cout << "═══════════════════════════════════════════════════════════════════════════════" << endl;
        cout << "This tree shows how each mathematical concept builds upon the previous layer," << endl;
        cout << "from Euclid's ancient algorithm to modern Diophantine approximation theory." << endl;
        cout << "═══════════════════════════════════════════════════════════════════════════════" << endl;
        cout << "\n\n";
    }
};

using namespace std;

// Structure to hold a rational number
struct Rational {
    long long numerator;
    long long denominator;
    
    double value() const {
        return static_cast<double>(numerator) / denominator;
    }
    
    double error(double target) const {
        return abs(value() - target);
    }
};

// Structure to hold continued fraction analysis results
struct CFAnalysis {
    vector<long long> cfCoefficients;  // The continued fraction [a0; a1, a2, ...]
    vector<Rational> convergents;       // The rational convergents
    vector<double> errors;              // Error at each convergent
    double targetValue;
};

class ContinuedFractionAnalyzer {
private:
    const double EPSILON = 1e-12;
    const long long MAX_DENOMINATOR = 1e9;
    
public:
    // Main algorithm: Convert a real number to continued fraction and find convergents
    CFAnalysis analyze(double x, int maxTerms = 20) {
        CFAnalysis result;
        result.targetValue = x;
        
        double value = x;
        vector<long long> cf;
        
        // Step 1: Extract continued fraction coefficients
        cout << "\n=== CONTINUED FRACTION EXTRACTION ===" << endl;
        cout << "Target value: " << fixed << setprecision(15) << x << endl;
        cout << "\nCF Coefficients: [";
        
        for (int i = 0; i < maxTerms && abs(value) > EPSILON; i++) {
            long long ai = static_cast<long long>(floor(value));
            cf.push_back(ai);
            
            if (i == 0) cout << ai;
            else cout << ", " << ai;
            
            value = value - ai;
            
            if (abs(value) < EPSILON) break;
            value = 1.0 / value;
        }
        cout << "]" << endl;
        
        result.cfCoefficients = cf;
        
        // Step 2: Compute convergents using the recurrence relation
        // p_n = a_n * p_{n-1} + p_{n-2}
        // q_n = a_n * q_{n-1} + q_{n-2}
        
        cout << "\n=== CONVERGENTS (BEST RATIONAL APPROXIMATIONS) ===" << endl;
        cout << left << setw(5) << "n" 
             << setw(12) << "a_n" 
             << setw(20) << "Convergent (p/q)"
             << setw(20) << "Decimal"
             << setw(20) << "Error" << endl;
        cout << string(77, '-') << endl;
        
        long long p_prev = 0, p_curr = 1;
        long long q_prev = 1, q_curr = 0;
        
        for (size_t n = 0; n < cf.size(); n++) {
            long long a_n = cf[n];
            
            // Recurrence relation
            long long p_new = a_n * p_curr + p_prev;
            long long q_new = a_n * q_curr + q_prev;
            
            // Check for overflow or denominator too large
            if (q_new > MAX_DENOMINATOR) {
                cout << "Stopping: denominator exceeded " << MAX_DENOMINATOR << endl;
                break;
            }
            
            Rational convergent = {p_new, q_new};
            double err = convergent.error(x);
            
            result.convergents.push_back(convergent);
            result.errors.push_back(err);
            
            cout << left << setw(5) << n
                 << setw(12) << a_n
                 << setw(20) << (to_string(p_new) + "/" + to_string(q_new))
                 << setw(20) << fixed << setprecision(15) << convergent.value()
                 << scientific << setprecision(6) << err << endl;
            
            // Update for next iteration
            p_prev = p_curr;
            p_curr = p_new;
            q_prev = q_curr;
            q_curr = q_new;
        }
        
        return result;
    }
    
    // Find the best approximation with denominator constraint
    Rational findBestApproximation(double x, long long maxDenom) {
        CFAnalysis analysis = analyze(x, 50);
        
        cout << "\n=== BEST APPROXIMATION WITH q <= " << maxDenom << " ===" << endl;
        
        Rational best = {0, 1};
        double bestError = numeric_limits<double>::max();
        
        for (const auto& conv : analysis.convergents) {
            if (conv.denominator <= maxDenom) {
                double err = conv.error(x);
                if (err < bestError) {
                    best = conv;
                    bestError = err;
                }
            }
        }
        
        cout << "Best rational: " << best.numerator << "/" << best.denominator 
             << " = " << fixed << setprecision(15) << best.value() << endl;
        cout << "Error: " << scientific << bestError << endl;
        
        return best;
    }
    
    // Analyze special mathematical constants
    void analyzeConstant(const string& name, double value) {
        cout << "\n" << string(80, '=') << endl;
        cout << "ANALYZING: " << name << endl;
        cout << string(80, '=') << endl;
        
        CFAnalysis result = analyze(value, 15);
        
        // Identify patterns in CF coefficients
        cout << "\n=== PATTERN ANALYSIS ===" << endl;
        analyzePattern(result.cfCoefficients, name);
    }
    
private:
    void analyzePattern(const vector<long long>& cf, const string& name) {
        if (cf.empty()) return;
        
        // Check for all 1s (Golden Ratio pattern)
        bool allOnes = true;
        for (size_t i = 1; i < min(cf.size(), size_t(10)); i++) {
            if (cf[i] != 1) {
                allOnes = false;
                break;
            }
        }
        
        if (allOnes && cf.size() > 5) {
            cout << "★ GOLDEN RATIO PATTERN DETECTED: All coefficients are 1!" << endl;
            cout << "  This is the 'most irrational' number (Hurwitz's theorem)" << endl;
            cout << "  Convergents are ratios of consecutive Fibonacci numbers." << endl;
            return;
        }
        
        // Check for e pattern: [2; 1,2,1, 1,4,1, 1,6,1, ...]
        if (cf.size() > 6 && cf[0] == 2) {
            bool ePattern = true;
            for (size_t i = 1; i < min(cf.size(), size_t(10)); i += 3) {
                if (i < cf.size() && cf[i] != 1) { ePattern = false; break; }
                if (i+1 < cf.size() && cf[i+1] != 2*((i+2)/3)) { ePattern = false; break; }
                if (i+2 < cf.size() && cf[i+2] != 1) { ePattern = false; break; }
            }
            if (ePattern) {
                cout << "★ EULER'S NUMBER PATTERN: [2; 1,2n,1] repeating!" << endl;
                cout << "  Pattern: 2, then blocks of [1, 2n, 1] where n=1,2,3,..." << endl;
                return;
            }
        }
        
        // Check for periodic pattern (quadratic irrationals)
        for (size_t period = 1; period <= cf.size()/3; period++) {
            bool isPeriodic = true;
            for (size_t i = period + 1; i < min(cf.size(), period*3 + 1); i++) {
                if (cf[i] != cf[i % period + 1]) {
                    isPeriodic = false;
                    break;
                }
            }
            if (isPeriodic && period > 1) {
                cout << "★ PERIODIC PATTERN (period " << period << "): Quadratic irrational!" << endl;
                cout << "  These arise from solutions to quadratic equations." << endl;
                return;
            }
        }
        
        cout << "Pattern: Mixed/Aperiodic (typical for transcendental numbers)" << endl;
    }
};

// Pre-computed mathematical constants
namespace Constants {
    const double PHI = 1.618033988749895;           // Golden Ratio
    const double E = 2.718281828459045;              // Euler's number
    const double PI = 3.141592653589793;             // Pi
    const double SQRT2 = 1.414213562373095;          // √2
    const double SQRT3 = 1.732050807568877;          // √3
    const double LN2 = 0.693147180559945;            // ln(2)
}

int main() {
    // First, show the tree of mathematical understanding
    MathTree tree;
    tree.display();
    
    cout << "\n\nPress ENTER to begin analysis using these principles..." << endl;
    cin.ignore();
    cin.get();
    
    ContinuedFractionAnalyzer analyzer;
    
    cout << "\n\n";
    cout << "╔════════════════════════════════════════════════════════════════════╗" << endl;
    cout << "║   CONTINUED FRACTION RATIONAL APPROXIMATION ANALYZER              ║" << endl;
    cout << "║                                                                    ║" << endl;
    cout << "║   Mathematical Foundation: Convergents Theorem                    ║" << endl;
    cout << "║   Convergents of continued fractions are the BEST rational        ║" << endl;
    cout << "║   approximations: no fraction with smaller denominator is closer  ║" << endl;
    cout << "╚════════════════════════════════════════════════════════════════════╝" << endl;
    
    // Analyze famous mathematical constants
    analyzer.analyzeConstant("Golden Ratio (φ)", Constants::PHI);
    analyzer.analyzeConstant("Euler's Number (e)", Constants::E);
    analyzer.analyzeConstant("Pi (π)", Constants::PI);
    analyzer.analyzeConstant("Square Root of 2 (√2)", Constants::SQRT2);
    
    // Interactive mode
    cout << "\n\n" << string(80, '=') << endl;
    cout << "INTERACTIVE MODE" << endl;
    cout << string(80, '=') << endl;
    
    double customValue;
    cout << "\nEnter a real number to analyze: ";
    cin >> customValue;
    
    analyzer.analyzeConstant("Your Custom Value", customValue);
    
    // Find best approximation with constraint
    long long maxDenom;
    cout << "\nEnter maximum denominator for best approximation: ";
    cin >> maxDenom;
    
    analyzer.findBestApproximation(customValue, maxDenom);
    
    cout << "\n\n=== SUMMARY ===" << endl;
    cout << "This program implements the classical continued fraction algorithm," << endl;
    cout << "a well-established method in number theory for finding the best" << endl;
    cout << "rational approximations to real numbers. The convergents produced" << endl;
    cout << "are provably optimal by Legendre's and Hurwitz's theorems." << endl;
    
    return 0;
}