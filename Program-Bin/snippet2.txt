/*
 * THE RIGOROUS NUMERICAL ANALYSIS SUITE (SPECTRAL & ERGODIC EDITION)
 * --------------------------------------------------------------------
 * COMPLEMENTARY SYSTEM TO THE RECIPROCAL PROOF FRAMEWORK
 * * FOCUS:
 * - Spectral Analysis (Discrete Fourier Transform of Digits)
 * - Ergodic Theory (Khinchin & Lévy Constants)
 * - Information Theory (Shannon Entropy)
 * - Complex Analysis (Möbius Stability & Conformal Mapping)
 * - Numerical Stability (Condition Number Auditing)
 */

#include <iostream>
#include <iomanip>
#include <string>
#include <vector>
#include <cmath>
#include <complex>
#include <map>
#include <numeric>
#include <algorithm>
#include <random>
#include <boost/multiprecision/cpp_dec_float.hpp>
#include <boost/math/constants/constants.hpp>
#include <boost/math/special_functions/gamma.hpp>
#include <boost/math/special_functions/zeta.hpp>

// ============================== CONFIGURATION ==============================
// We use 200 digits here to balance the heavy load of DFT and Complex math
// while maintaining rigorous precision.
using namespace boost::multiprecision;
using high_float = number<cpp_dec_float<200>>;
using Complex = std::complex<high_float>;

const high_float PI = boost::math::constants::pi<high_float>();
const high_float E = boost::math::constants::e<high_float>();
const high_float KHINCHIN_THEORETICAL = high_float("2.685452001065306445309714835481795693820382");
const high_float LEVY_THEORETICAL = high_float("3.275822918721811159787681882453843862599949");

// ============================== UTILITIES ==============================

void banner(const std::string& text) {
    std::cout << "\n======================================================================\n";
    std::cout << "  " << text << "\n";
    std::cout << "======================================================================\n";
}

std::string format_float(const high_float& x, int digits = 20) {
    std::stringstream ss;
    ss << std::fixed << std::setprecision(digits) << x;
    return ss.str();
}

// Extract fractional digits as a vector of integers
std::vector<int> get_digit_signal(const high_float& x, size_t count) {
    std::vector<int> signal;
    high_float val = abs(x);
    val -= floor(val); // Fractional part only
    
    for(size_t i = 0; i < count; ++i) {
        val *= 10;
        int digit = static_cast<int>(floor(val));
        signal.push_back(digit);
        val -= digit;
        if(val == 0) break; // Terminating decimal
    }
    return signal;
}

// Continued Fraction Generator (Iterative)
std::vector<unsigned long long> generate_cf(high_float x, size_t max_terms) {
    std::vector<unsigned long long> terms;
    if (x == 0) return terms;
    
    for(size_t i = 0; i < max_terms; ++i) {
        high_float whole = floor(x);
        // Safety cap for huge terms to prevent overflow in analysis
        if (whole > 1000000000ULL) whole = 1000000000ULL; 
        
        terms.push_back(static_cast<unsigned long long>(whole));
        x -= whole;
        if (x < 1e-100) break;
        x = 1 / x;
    }
    return terms;
}

// ============================== MODULE 1: INFORMATION THEORY ==============================

void analyze_shannon_entropy(const high_float& x) {
    banner("MODULE I: INFORMATION THEORETIC ANALYSIS (SHANNON ENTROPY)");
    
    std::vector<int> digits = get_digit_signal(x, 500); // Analyze first 500 fractional digits
    if (digits.size() < 10) {
        std::cout << "  [!] Insufficient digits for entropy analysis (Terminating Decimal).\n";
        return;
    }

    std::map<int, int> frequencies;
    for (int d : digits) frequencies[d]++;

    high_float entropy = 0;
    high_float N = digits.size();
    
    std::cout << "  Digit Distribution (First " << N << " digits):\n";
    for (int i = 0; i <= 9; ++i) {
        high_float p_i = high_float(frequencies[i]) / N;
        if (p_i > 0) {
            entropy -= p_i * log2(p_i);
        }
        if (frequencies[i] > 0) {
           // std::cout << "    " << i << ": " << frequencies[i] << " (" << format_float(p_i*100, 1) << "%)\n";
        }
    }

    // Theoretical max entropy for base 10 is log2(10) ≈ 3.3219
    high_float max_entropy = log2(high_float(10));
    high_float efficiency = (entropy / max_entropy) * 100;

    std::cout << "  Calculated Shannon Entropy: " << format_float(entropy, 5) << " bits/symbol\n";
    std::cout << "  Theoretical Max (Uniform):  " << format_float(max_entropy, 5) << " bits/symbol\n";
    std::cout << "  Information Density:        " << format_float(efficiency, 2) << "%\n";

    std::cout << "\n  INTERPRETATION:\n";
    if (efficiency > 99.0) {
        std::cout << "  [NORMAL] The digit sequence exhibits high randomness/uniformity.\n"
                  << "  This suggests a typical irrational number or a high-quality generator.\n";
    } else if (efficiency > 90.0) {
        std::cout << "  [STRUCTURED] Slight statistical bias detected. Typical of some algebraic roots.\n";
    } else {
        std::cout << "  [LOW ENTROPY] Significant pattern or repetition detected.\n"
                  << "  The number likely has a rational structure or specific non-normal property.\n";
    }
}

// ============================== MODULE 2: SPECTRAL ANALYSIS ==============================

void analyze_spectral_properties(const high_float& x) {
    banner("MODULE II: SPECTRAL ANALYSIS (DISCRETE FOURIER TRANSFORM)");
    std::cout << "  Treating decimal expansion as a discrete time signal x[n]...\n";

    std::vector<int> raw_signal = get_digit_signal(x, 256); // Power of 2 for clean DFT
    if (raw_signal.size() < 256) {
        std::cout << "  [!] Signal too short for spectral analysis.\n";
        return;
    }

    // Convert digit signal to centered high_float signal
    std::vector<high_float> signal;
    high_float mean = 0;
    for (int d : raw_signal) {
        high_float val = static_cast<high_float>(d);
        signal.push_back(val);
        mean += val;
    }
    mean /= signal.size();
    // Remove DC offset (mean) to see periodicity clearly
    for (auto& s : signal) s -= mean;

    // Slow DFT (O(N^2)) - acceptable for N=256 and ensures high precision handling
    size_t N = signal.size();
    std::vector<high_float> magnitude(N / 2);
    high_float max_mag = 0;
    int peak_freq = 0;

    for (size_t k = 0; k < N / 2; ++k) {
        Complex sum(0, 0);
        Complex i(0, 1);
        for (size_t n = 0; n < N; ++n) {
            high_float theta = -2 * PI * k * n / N;
            // Euler's formula: e^(ix) = cos(x) + i*sin(x)
            Complex exp_val(cos(theta), sin(theta)); 
            Complex sig_val(signal[n], 0);
            sum += sig_val * exp_val;
        }
        magnitude[k] = sqrt(norm(sum)); // norm gives mag^2
        if (k > 0 && magnitude[k] > max_mag) { // Ignore DC component at k=0
            max_mag = magnitude[k];
            peak_freq = k;
        }
    }

    std::cout << "  Analysis of " << N << "-point frequency domain:\n";
    std::cout << "  Dominant Frequency Index: " << peak_freq << "\n";
    std::cout << "  Peak Magnitude: " << format_float(max_mag, 4) << "\n";

    // Detect periodicity via Spectral Leakage check
    high_float noise_floor = 0;
    for (size_t k = 1; k < N/2; ++k) noise_floor += magnitude[k];
    noise_floor /= (N/2 - 1);
    
    high_float snr = (noise_floor > 0) ? max_mag / noise_floor : high_float(0);

    std::cout << "  Spectral Signal-to-Noise Ratio (SNR): " << format_float(snr, 2) << "\n";

    std::cout << "\n  INTERPRETATION:\n";
    if (snr > 10.0) {
        std::cout << "  [PERIODIC] Strong periodic components detected in the digits.\n"
                  << "  This implies a repeating decimal (Rational number).\n";
    } else if (snr > 3.0) {
        std::cout << "  [WEAK PATTERN] Some correlations exist, but no strict periodicity.\n";
    } else {
        std::cout << "  [WHITE NOISE] The digit spectrum is flat.\n"
                  << "  This confirms the digits are spectrally indistinguishable from random noise.\n";
    }
}