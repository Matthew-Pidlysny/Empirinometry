class ExtremeTimeSeriesAnalysis {
private:
    AlignedVector<Float64> series;
    Int64 seasonality_period;
    PrecisionTimer timer;
    
public:
    ExtremeTimeSeriesAnalysis(const AlignedVector<Float64>& time_series, 
                            Int64 seasonality = 0)
        : series(time_series), seasonality_period(seasonality) {}
    
    struct Decomposition {
        AlignedVector<Float64> trend;
        AlignedVector<Float64> seasonal;
        AlignedVector<Float64> residual;
        Float64 trend_strength;
        Float64 season_strength;
    };
    
    Decomposition stlDecomposition(Int64 trend_window = -1) {
        timer.start();
        
        if (trend_window == -1) {
            trend_window = max(static_cast<Int64>(series.size() / 10), 3LL);
        }
        
        Decomposition result;
        result.trend = loessSmoothing(series, trend_window);
        
        // Calculate seasonal component if period is specified
        if (seasonality_period > 0) {
            result.seasonal = extractSeasonalComponent(series, result.trend);
            result.season_strength = calculateSeasonalStrength(result.seasonal);
        } else {
            result.seasonal.resize(series.size(), 0.0);
            result.season_strength = 0.0;
        }
        
        // Calculate residuals
        result.residual.resize(series.size());
        #pragma omp parallel for
        for (Int64 i = 0; i < static_cast<Int64>(series.size()); i++) {
            result.residual[i] = series[i] - result.trend[i] - result.seasonal[i];
        }
        
        result.trend_strength = calculateTrendStrength(result.trend, result.residual);
        
        double elapsed = timer.elapsed();
        cout << "=== EXTREME TIME SERIES DECOMPOSITION ===" << endl;
        cout << "Data points: " << series.size() << endl;
        cout << "Trend window: " << trend_window << endl;
        cout << "Seasonality: " << seasonality_period << endl;
        cout << "Trend strength: " << result.trend_strength << endl;
        cout << "Seasonal strength: " << result.season_strength << endl;
        cout << "Decomposition time: " << elapsed * 1000 << " ms" << endl;
        
        return result;
    }
    
    AlignedVector<Float64> forecastARIMA(Int64 steps = 10, Int64 p = 2, Int64 d = 1, Int64 q = 2) {
        timer.start();
        
        // Differencing for stationarity
        AlignedVector<Float64> differenced = series;
        for (Int64 i = 0; i < d; i++) {
            AlignedVector<Float64> temp(differenced.size() - 1);
            for (size_t j = 1; j < differenced.size(); j++) {
                temp[j-1] = differenced[j] - differenced[j-1];
            }
            differenced = temp;
        }
        
        // Simple AR model forecasting (simplified)
        AlignedVector<Float64> forecasts(steps, 0.0);
        Int64 n = differenced.size();
        
        // Use last p values for prediction
        for (Int64 step = 0; step < steps; step++) {
            Float64 prediction = 0.0;
            for (Int64 lag = 1; lag <= min(p, n); lag++) {
                prediction += 0.5 * differenced[n - lag]; // Simple coefficients
            }
            forecasts[step] = prediction;
            // Update differenced for next prediction
            differenced.push_back(prediction);
            n++;
        }
        
        // Reverse differencing
        AlignedVector<Float64> final_forecasts(steps);
        Float64 last_value = series.back();
        for (Int64 i = 0; i < steps; i++) {
            last_value += forecasts[i];
            final_forecasts[i] = last_value;
        }
        
        double elapsed = timer.elapsed();
        cout << "\n=== ARIMA FORECASTING ===" << endl;
        cout << "Model: ARIMA(" << p << "," << d << "," << q << ")" << endl;
        cout << "Forecast steps: " << steps << endl;
        cout << "Forecasting time: " << elapsed * 1000 << " ms" << endl;
        
        return final_forecasts;
    }
    
    struct AnomalyDetection {
        vector<Int64> anomaly_indices;
        AlignedVector<Float64> anomaly_scores;
        Float64 threshold;
    };
    
    AnomalyDetection detectAnomalies(Float64 sensitivity = 2.0) {
        AnomalyDetection result;
        
        // Use median absolute deviation for robust anomaly detection
        Float64 median = calculateMedian(series);
        AlignedVector<Float64> absolute_deviations(series.size());
        
        transform(execution::par_unseq, series.begin(), series.end(),
                 absolute_deviations.begin(), [median](Float64 x) { 
                     return abs(x - median); });
        
        Float64 mad = calculateMedian(absolute_deviations);
        result.threshold = median + sensitivity * 1.4826 * mad;
        
        // Find anomalies
        for (Int64 i = 0; i < static_cast<Int64>(series.size()); i++) {
            Float64 score = abs(series[i] - median) / (1.4826 * mad + 1e-8);
            result.anomaly_scores.push_back(score);
            if (series[i] > result.threshold) {
                result.anomaly_indices.push_back(i);
            }
        }
        
        cout << "\n=== ANOMALY DETECTION ===" << endl;
        cout << "Anomalies found: " << result.anomaly_indices.size() << endl;
        cout << "Threshold: " << result.threshold << endl;
        cout << "Sensitivity: " << sensitivity << endl;
        
        return result;
    }
    
private:
    AlignedVector<Float64> loessSmoothing(const AlignedVector<Float64>& data, Int64 window) {
        AlignedVector<Float64> smoothed(data.size());
        
        #pragma omp parallel for
        for (Int64 i = 0; i < static_cast<Int64>(data.size()); i++) {
            Int64 start = max(0LL, i - window/2);
            Int64 end = min(static_cast<Int64>(data.size()), i + window/2 + 1);
            
            Float64 sum = 0.0;
            for (Int64 j = start; j < end; j++) {
                sum += data[j];
            }
            smoothed[i] = sum / (end - start);
        }
        
        return smoothed;
    }
    
    AlignedVector<Float64> extractSeasonalComponent(const AlignedVector<Float64>& data, 
                                                   const AlignedVector<Float64>& trend) {
        AlignedVector<Float64> detrended(data.size());
        #pragma omp parallel for
        for (Int64 i = 0; i < static_cast<Int64>(data.size()); i++) {
            detrended[i] = data[i] - trend[i];
        }
        
        AlignedVector<Float64> seasonal(data.size(), 0.0);
        vector<AlignedVector<Float64>> seasonal_buckets(seasonality_period);
        
        // Group by seasonal position
        for (Int64 i = 0; i < static_cast<Int64>(data.size()); i++) {
            Int64 bucket = i % seasonality_period;
            seasonal_buckets[bucket].push_back(detrended[i]);
        }
        
        // Calculate seasonal averages
        AlignedVector<Float64> seasonal_pattern(seasonality_period);
        for (Int64 i = 0; i < seasonality_period; i++) {
            seasonal_pattern[i] = HighPrecisionStats::mean_simd(seasonal_buckets[i]);
        }
        
        // Remove mean from seasonal pattern
        Float64 pattern_mean = HighPrecisionStats::mean_simd(seasonal_pattern);
        for (Int64 i = 0; i < seasonality_period; i++) {
            seasonal_pattern[i] -= pattern_mean;
        }
        
        // Apply seasonal pattern
        for (Int64 i = 0; i < static_cast<Int64>(data.size()); i++) {
            seasonal[i] = seasonal_pattern[i % seasonality_period];
        }
        
        return seasonal;
    }
    
    Float64 calculateMedian(const AlignedVector<Float64>& data) {
        auto sorted = data;
        sort(execution::par_unseq, sorted.begin(), sorted.end());
        Int64 mid = sorted.size() / 2;
        if (sorted.size() % 2 == 0) {
            return (sorted[mid-1] + sorted[mid]) / 2.0;
        } else {
            return sorted[mid];
        }
    }
    
    Float64 calculateTrendStrength(const AlignedVector<Float64>& trend, 
                                 const AlignedVector<Float64>& residual) {
        Float64 var_trend = HighPrecisionStats::variance_parallel(trend);
        Float64 var_residual = HighPrecisionStats::variance_parallel(residual);
        return max(0.0, 1.0 - var_residual / (var_trend + var_residual + 1e-8));
    }
    
    Float64 calculateSeasonalStrength(const AlignedVector<Float64>& seasonal) {
        if (seasonal.empty()) return 0.0;
        Float64 var_seasonal = HighPrecisionStats::variance_parallel(seasonal);
        Float64 var_series = HighPrecisionStats::variance_parallel(series);
        return var_seasonal / (var_series + 1e-8);
    }
};

class ExtremeSieveMethods {
private:
    static constexpr Int64 CACHE_SIZE = 32768; // 32KB cache-friendly blocks
    PrecisionTimer timer;
    
public:
    // Ultra-optimized segmented sieve with cache blocking
    vector<Int64> segmentedSieveUltra(Int64 limit) {
        timer.start();
        
        Int64 sqrt_limit = static_cast<Int64>(sqrt(limit)) + 1;
        auto base_primes = sieveOfEratosthenes(sqrt_limit);
        
        vector<Int64> all_primes = base_primes;
        Int64 segment_size = min(CACHE_SIZE, limit - sqrt_limit);
        
        for (Int64 low = sqrt_limit; low <= limit; low += segment_size) {
            Int64 high = min(low + segment_size - 1, limit);
            vector<bool> is_prime_segment(segment_size, true);
            
            for (Int64 p : base_primes) {
                Int64 start = max(p * p, ((low + p - 1) / p) * p);
                for (Int64 j = start; j <= high; j += p) {
                    is_prime_segment[j - low] = false;
                }
            }
            
            for (Int64 i = low; i <= high; i++) {
                if (is_prime_segment[i - low] && i > 1) {
                    all_primes.push_back(i);
                }
            }
        }
        
        double elapsed = timer.elapsed();
        cout << "=== EXTREME SIEVE PERFORMANCE ===" << endl;
        cout << "Primes up to: " << limit << endl;
        cout << "Primes found: " << all_primes.size() << endl;
        cout << "Largest prime: " << (all_primes.empty() ? 0 : all_primes.back()) << endl;
        cout << "Computation time: " << elapsed * 1000 << " ms" << endl;
        cout << "Primes per second: " << all_primes.size() / elapsed << endl;
        
        return all_primes;
    }
    
    // Parallel prime counting function with Legendre's formula
    Int64 primeCountUltra(Int64 limit) {
        if (limit < 2) return 0;
        
        Int64 sqrt_limit = static_cast<Int64>(sqrt(limit));
        auto primes = sieveOfEratosthenes(sqrt_limit);
        
        // Legendre's formula: π(x) = π(√x) + φ(x, π(√x)) - 1
        return primes.size() + phiFunction(limit, primes.size(), primes) - 1;
    }
    
    // Miller-Rabin primality test for large numbers
    bool isPrimeMillerRabin(Int64 n, Int64 iterations = 10) {
        if (n < 2) return false;
        if (n == 2 || n == 3) return true;
        if (n % 2 == 0) return false;
        
        // Write n-1 as d*2^s
        Int64 d = n - 1;
        Int64 s = 0;
        while (d % 2 == 0) {
            d /= 2;
            s++;
        }
        
        random_device rd;
        mt19937_64 gen(rd());
        uniform_int_distribution<Int64> dist(2, n - 2);
        
        for (Int64 i = 0; i < iterations; i++) {
            Int64 a = dist(gen);
            Int64 x = modularPow(a, d, n);
            
            if (x == 1 || x == n - 1) continue;
            
            bool composite = true;
            for (Int64 r = 1; r < s; r++) {
                x = modularPow(x, 2, n);
                if (x == n - 1) {
                    composite = false;
                    break;
                }
            }
            
            if (composite) return false;
        }
        
        return true;
    }
    
private:
    vector<Int64> sieveOfEratosthenes(Int64 n) {
        if (n < 2) return {};
        
        vector<bool> is_prime(n + 1, true);
        is_prime[0] = is_prime[1] = false;
        
        for (Int64 i = 2; i * i <= n; i++) {
            if (is_prime[i]) {
                for (Int64 j = i * i; j <= n; j += i) {
                    is_prime[j] = false;
                }
            }
        }
        
        vector<Int64> primes;
        for (Int64 i = 2; i <= n; i++) {
            if (is_prime[i]) {
                primes.push_back(i);
            }
        }
        
        return primes;
    }
    
    Int64 phiFunction(Int64 x, Int64 a, const vector<Int64>& primes) {
        if (a == 0) return x;
        if (x < primes[a - 1]) return 1;
        
        return phiFunction(x, a - 1, primes) - phiFunction(x / primes[a - 1], a - 1, primes);
    }
    
    Int64 modularPow(Int64 base, Int64 exponent, Int64 modulus) {
        Int64 result = 1;
        base %= modulus;
        
        while (exponent > 0) {
            if (exponent & 1) {
                result = (result * base) % modulus;
            }
            base = (base * base) % modulus;
            exponent >>= 1;
        }
        
        return result;
    }
};