#include <iostream>
#include <vector>
#include <map>
#include <cmath>
#include <iomanip>
#include <algorithm>
#include <numeric>

using namespace std;

// Extended Euclidean Algorithm to find modular inverse
long long extGCD(long long a, long long b, long long &x, long long &y) {
    if (b == 0) {
        x = 1;
        y = 0;
        return a;
    }
    long long x1, y1;
    long long gcd = extGCD(b, a % b, x1, y1);
    x = y1;
    y = x1 - (a / b) * y1;
    return gcd;
}

// Find modular inverse of a mod n, returns -1 if doesn't exist
long long modInverse(long long a, long long n) {
    long long x, y;
    long long gcd = extGCD(a, n, x, y);
    if (gcd != 1) return -1; // Inverse doesn't exist
    return (x % n + n) % n;
}

// Check if n is prime (simple trial division for our purposes)
bool isPrime(long long n) {
    if (n < 2) return false;
    if (n == 2) return true;
    if (n % 2 == 0) return false;
    for (long long i = 3; i * i <= n; i += 2) {
        if (n % i == 0) return false;
    }
    return true;
}

// Modular multiplication to avoid overflow
long long modMul(long long a, long long b, long long mod) {
    return ((a % mod) * (b % mod)) % mod;
}

// Analysis Structure
struct ReciprocalAnalysis {
    long long n;
    bool is_prime;
    
    // Reciprocal mapping
    map<long long, long long> inverse_map;
    vector<long long> self_inverse;
    
    // Metric 1: Average Reciprocal Distance
    double avg_reciprocal_distance;
    
    // Metric 2: Partial Wilson Products
    vector<long long> partial_wilson;
    
    // Metric 3: Graph properties
    int num_self_loops;
    int num_cycles;
    double avg_cycle_length;
    
    // Metric 4: Wilson Deviation
    long long wilson_deviation;
    
    // Metric 5: Cumulative Reciprocal Signature
    long long cumulative_reciprocal_sig;
};

// Build the reciprocal mapping
void buildReciprocalMap(ReciprocalAnalysis &analysis) {
    long long n = analysis.n;
    
    for (long long i = 1; i < n; i++) {
        long long inv = modInverse(i, n);
        if (inv != -1) {
            analysis.inverse_map[i] = inv;
            if (i == inv) {
                analysis.self_inverse.push_back(i);
            }
        }
    }
    
    analysis.num_self_loops = analysis.self_inverse.size();
}

// Metric 1: Reciprocal Distance
void computeReciprocalDistance(ReciprocalAnalysis &analysis) {
    long long n = analysis.n;
    double total_distance = 0.0;
    int count = 0;
    
    for (auto &pair : analysis.inverse_map) {
        long long a = pair.first;
        long long a_inv = pair.second;
        double distance = abs(a - a_inv) / (double)n;
        total_distance += distance;
        count++;
    }
    
    analysis.avg_reciprocal_distance = (count > 0) ? total_distance / count : 0.0;
}

// Metric 2: Partial Wilson Products (reciprocal-weighted)
void computePartialWilson(ReciprocalAnalysis &analysis) {
    long long n = analysis.n;
    long long product = 1;
    
    // Store every 10th value to avoid huge vectors
    int sample_rate = max(1LL, (n - 1) / 100);
    
    for (long long k = 1; k < n; k++) {
        long long k_inv = modInverse(k, n);
        if (k_inv != -1) {
            product = modMul(product, modMul(k, k_inv, n), n);
        }
        
        if (k % sample_rate == 0 || k == n - 1) {
            analysis.partial_wilson.push_back(product);
        }
    }
}

// Metric 3: Graph cycle analysis
void analyzeReciprocalGraph(ReciprocalAnalysis &analysis) {
    long long n = analysis.n;
    vector<bool> visited(n, false);
    vector<int> cycle_lengths;
    
    for (long long start = 1; start < n; start++) {
        if (visited[start] || analysis.inverse_map.find(start) == analysis.inverse_map.end()) 
            continue;
        
        vector<long long> path;
        long long current = start;
        
        while (!visited[current] && analysis.inverse_map.find(current) != analysis.inverse_map.end()) {
            visited[current] = true;
            path.push_back(current);
            current = analysis.inverse_map[current];
            
            // Check if we've completed a cycle
            if (current == start) {
                cycle_lengths.push_back(path.size());
                break;
            }
            
            // Safety check for infinite loops
            if (path.size() > n) break;
        }
    }
    
    analysis.num_cycles = cycle_lengths.size();
    
    if (!cycle_lengths.empty()) {
        analysis.avg_cycle_length = accumulate(cycle_lengths.begin(), cycle_lengths.end(), 0.0) / cycle_lengths.size();
    } else {
        analysis.avg_cycle_length = 0.0;
    }
}

// Metric 4: Wilson Deviation Function
void computeWilsonDeviation(ReciprocalAnalysis &analysis) {
    long long n = analysis.n;
    
    // For small n, compute factorial mod n^2
    if (n <= 20) {
        long long fact = 1;
        long long n_squared = n * n;
        
        for (long long i = 1; i < n; i++) {
            fact = modMul(fact, i, n_squared);
        }
        
        analysis.wilson_deviation = (fact + 1) % n_squared;
    } else {
        // For larger n, use modular arithmetic mod n
        long long fact = 1;
        for (long long i = 1; i < n; i++) {
            fact = modMul(fact, i, n);
        }
        analysis.wilson_deviation = (fact + 1) % n;
    }
}

// Metric 5: Cumulative Reciprocal Signature
void computeCumulativeReciprocalSignature(ReciprocalAnalysis &analysis) {
    long long n = analysis.n;
    long long sum = 0;
    long long mod = (n <= 100) ? n * n : n;
    
    for (long long k = 1; k < n; k++) {
        long long k_inv = modInverse(k, n);
        if (k_inv != -1) {
            sum = (sum + k + k_inv) % mod;
        }
    }
    
    analysis.cumulative_reciprocal_sig = sum;
}

// Full analysis pipeline
ReciprocalAnalysis analyzeInteger(long long n) {
    ReciprocalAnalysis analysis;
    analysis.n = n;
    analysis.is_prime = isPrime(n);
    
    cout << "\n========================================" << endl;
    cout << "Analyzing n = " << n << " (Prime: " << (analysis.is_prime ? "YES" : "NO") << ")" << endl;
    cout << "========================================" << endl;
    
    buildReciprocalMap(analysis);
    cout << "✓ Built reciprocal map: " << analysis.inverse_map.size() << " elements with inverses" << endl;
    cout << "  Self-inverse elements: " << analysis.num_self_loops << " ";
    for (auto si : analysis.self_inverse) cout << si << " ";
    cout << endl;
    
    computeReciprocalDistance(analysis);
    cout << "✓ Average reciprocal distance: " << fixed << setprecision(6) << analysis.avg_reciprocal_distance << endl;
    
    computePartialWilson(analysis);
    cout << "✓ Partial Wilson products computed (" << analysis.partial_wilson.size() << " samples)" << endl;
    if (!analysis.partial_wilson.empty()) {
        cout << "  Final partial product: " << analysis.partial_wilson.back() << endl;
    }
    
    analyzeReciprocalGraph(analysis);
    cout << "✓ Graph analysis: " << analysis.num_cycles << " cycles, avg length: " 
         << fixed << setprecision(2) << analysis.avg_cycle_length << endl;
    
    computeWilsonDeviation(analysis);
    cout << "✓ Wilson deviation: " << analysis.wilson_deviation << endl;
    
    computeCumulativeReciprocalSignature(analysis);
    cout << "✓ Cumulative reciprocal signature: " << analysis.cumulative_reciprocal_sig << endl;
    
    return analysis;
}

// Comparative analysis
void compareIntegers(const vector<long long> &numbers) {
    vector<ReciprocalAnalysis> results;
    
    cout << "\n\n╔════════════════════════════════════════════════════════╗" << endl;
    cout << "║     COMPARATIVE RECIPROCAL ANALYSIS BEGINS            ║" << endl;
    cout << "╚════════════════════════════════════════════════════════╝" << endl;
    
    for (long long n : numbers) {
        results.push_back(analyzeInteger(n));
    }
    
    cout << "\n\n╔════════════════════════════════════════════════════════╗" << endl;
    cout << "║              COMPARATIVE SUMMARY TABLE                 ║" << endl;
    cout << "╚════════════════════════════════════════════════════════╝" << endl;
    
    cout << "\n" << setw(6) << "n" << " | " << setw(6) << "Prime?" << " | " 
         << setw(10) << "SelfInv" << " | " << setw(12) << "AvgRecipDist" << " | "
         << setw(8) << "Cycles" << " | " << setw(12) << "WilsonDev" << " | "
         << setw(10) << "CumRecipSig" << endl;
    cout << string(90, '-') << endl;
    
    for (const auto &r : results) {
        cout << setw(6) << r.n << " | " 
             << setw(6) << (r.is_prime ? "YES" : "NO") << " | "
             << setw(10) << r.num_self_loops << " | "
             << setw(12) << fixed << setprecision(6) << r.avg_reciprocal_distance << " | "
             << setw(8) << r.num_cycles << " | "
             << setw(12) << r.wilson_deviation << " | "
             << setw(10) << r.cumulative_reciprocal_sig << endl;
    }
    
    cout << "\n\n╔════════════════════════════════════════════════════════╗" << endl;
    cout << "║                  KEY OBSERVATIONS                      ║" << endl;
    cout << "╚════════════════════════════════════════════════════════╝" << endl;
    
    // Find patterns
    cout << "\n→ Wilson Deviation (should be 0 for primes):" << endl;
    for (const auto &r : results) {
        cout << "  n=" << r.n << ": " << r.wilson_deviation 
             << (r.wilson_deviation == 0 ? " ✓ (PRIME)" : " ✗ (composite)") << endl;
    }
    
    cout << "\n→ Self-Inverse Elements (primes should have exactly 2):" << endl;
    for (const auto &r : results) {
        cout << "  n=" << r.n << ": " << r.num_self_loops 
             << (r.num_self_loops == 2 ? " ✓" : " (check structure)") << endl;
    }
}

int main() {
    cout << "╔═══════════════════════════════════════════════════════════╗" << endl;
    cout << "║   WILSON'S THEOREM RECIPROCAL ANALYSIS FRAMEWORK          ║" << endl;
    cout << "║   Innovative Integer & Reciprocal Structure Analysis      ║" << endl;
    cout << "╚═══════════════════════════════════════════════════════════╝" << endl;
    
    // Test suite: mix of primes and composites
    vector<long long> test_numbers = {
        5,      // Small prime
        7,      // Small prime
        11,     // Prime
        13,     // Prime
        6,      // Composite (2×3)
        9,      // Composite (3²)
        15,     // Composite (3×5)
        17,     // Prime
        21,     // Composite (3×7)
        23,     // Prime
        25,     // Composite (5²)
        29,     // Prime
        30      // Composite (2×3×5)
    };
    
    compareIntegers(test_numbers);
    
    cout << "\n\n╔════════════════════════════════════════════════════════╗" << endl;
    cout << "║              ANALYSIS COMPLETE                         ║" << endl;
    cout << "╚════════════════════════════════════════════════════════╝" << endl;
    
    return 0;
}